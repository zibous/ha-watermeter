## -----------------------------------------------------------------------------------------------------
##  ATOM LITE  S3  GRAY (ESP32)
##  ESP32S3FN8
##  Chip is ESP32-PICO-D4 (revision 1)
##  Crystal is 40MHz
##  Flash: 4096kB
##  Mode:DIO
##  Chip: ESP32 Features:EMB_FLASH,WIFI_BGN,BLE,BT, Cores:2
##  Revision:1
##  ESP-IDF: v4.4.2
##  Features: WiFi, BT, Dual Core, 240MHz, Embedded Flash,
##            VRef calibration in efuse, Coding Scheme None
##
##  RAM:   [=         ]  13.3% (used 43632 bytes from 327680 bytes)
##  Flash: [======    ]  59.8% (used 1097633 bytes from 1835008 bytes)
##
##  HAkey: inH49O9jBeK5yTGb1X2g4WV/1aS6YKUpu3Vu277fDgw=

##{
##    "media":"water",
##    "meter":"izar",
##    "name":"",
##    "id":"2140711b",
##    "last_month_total_m3":367.677,
##    "remaining_battery_life_y":12.5,
##    "total_m3":372.199,
##    "transmit_period_s":8,
##    "current_alarms":"no_alarm",
##    "last_month_measure_date":"2024-08-31",
##    "manufacture_year":"2021",
##    "prefix":"C21FA",
##    "previous_alarms":"no_alarm",
##    "serial_number":"000475",
##    "timestamp":"2024-09-22T20:16:55Z"
##}

##
## -----------------------------------------------------------------------------------------------------

substitutions:
  ## device settings
  hostname: "atom-watermeter"
  friendly_name: "Wasseruhr"
  device_description: "Production 2024: Wasserzähler ESP32-PICO-D4 + EBYTE TI CC1101 für IZAR module (Diehl IZAR RC 868 I R4 PL"

  # The format of the name should be author_name.project_name.
  projectname: "Peter Siebler.${hostname}"
  appversion: "1.2.0"
  hardware: "ATOM-LITE ESP32S3FN8"
  location: "Heizraum"
  watermeter_installed: "2024-03-01 14:00:00"

  ## logger settings
  log_level: "DEBUG" # not that logging need memory, so in production mode use "WARN"
  log_baudrate: "115200" # use 0 to disable serial UART port logging.

  ## ----------------
  ## used device pins
  ## ----------------
  # led_internal: 27
  # big_button:   39

  ## ----------------
  ## used device pins
  ## ----------------
  # EBYTE TI CC1101:
  # cs_pin:       22
  # clk_pin:      23
  # mosi_pin:     19
  # miso_pin:     33
  # gdo0_pin:     26
  # gdo2_pin:     32

## ----------------------------------------------------------------
## Board ATOM LITE
## ----------------------------------------------------------------
esp32:
  board: m5stack-atom
  framework:
    type: arduino

## ----------------------------------------------------------------
## Customize the frequency in which data is flushed to the flash.
## ----------------------------------------------------------------
preferences:
  flash_write_interval: 10min

## ----------------------------------------------------------------
## APPLICATION ESPHOME
## ----------------------------------------------------------------
esphome:
  name: ${hostname}
  build_path: ./build/${hostname}
  comment: ${device_description}
  on_boot:
    then:
      - globals.set:
          id: boot_counter
          value: !lambda "return id(boot_counter)+=1;"
      - logger.log:
          level: WARN
          tag: "system"
          format: "BOOTMESSAGE:${hostname} API is connected, Device ready!"
      - component.update: bootcounter
      - light.turn_on:
          id: internal_led
          brightness: 20%
          color_mode: RGB
          green: 100%
  on_shutdown:
    then:
      - logger.log:
          level: ERROR
          tag: "system"
          format: "BOOTMESSAGE:${hostname} is down!"
  project:
    # This allows creators to add the project name and version to the compiled code.
    # It is currently only exposed via the logger, mDNS and the device_info response
    # via the native API. The format of the name should be author_name.project_name.
    name: ${projectname}
    version: ${appversion}
  area: ${location}
  name_add_mac_suffix: false
  # minimum version of ESPHome required to compile.
  min_version: 2024.6.6

## ------------------------------------------------------------------
## EXTERNAL COMPONENTS
## https://esphome.io/components/external_components.html
## ------------------------------------------------------------------
external_components:
  # uses the version 3 from SzczepanLeon (github)
  # https://github.com/SzczepanLeon/esphome-components
  # You can make ESPHome check the repository every time by setting this option to 0s
  - source: github://SzczepanLeon/esphome-components@version_3
    refresh: 0s
    components: [wmbus]

## ------------------------------------------------------------------
## Global variables
## https://esphome.io/components/globals.html
## ------------------------------------------------------------------
globals:
  - id: boot_counter
    type: int
    restore_value: yes
    initial_value: "0"

  - id: wifi_connect
    type: int
    restore_value: yes
    initial_value: "0"

  - id: last_value
    type: float
    restore_value: yes
    initial_value: "0.00"

  - id: current_value
    type: float
    restore_value: yes
    initial_value: "0.00"

  - id: hour_value
    type: float
    restore_value: yes
    initial_value: "0.00"

  - id: daily_value
    type: float
    restore_value: yes
    initial_value: "0.00"

  - id: yesterday_value
    type: float
    restore_value: yes
    initial_value: "0.00"

  - id: week_value
    type: float
    restore_value: yes
    initial_value: "0.00"

  - id: lastmonth_value
    type: float
    restore_value: yes
    initial_value: "0.00"

  - id: year_value
    type: float
    restore_value: yes
    initial_value: "0.00"

  - id: send_millisecond
    type: int
    restore_value: no
    initial_value: "0"

  - id: cc1101_state
    type: int
    restore_value: no
    initial_value: "0"

  - id: alarm_error_text
    type: std::vector<std::string>
    restore_value: no
    # initial_value: '{"no error", "general_alarm","leakage","meter_blocked","back_flow","underflow","overflow","submarine","sensor_fraud","mechanical_fraud"}'
    initial_value: '{"Keiner", "Fehler","Zähler undicht","Zähler blockiert","Wasser Rückfluss","Wasser Unterlauf","Wasser Überlauf","Überschwemung","Sensor Fehler", "Mechanischer Fehler"}'

  - id: cc1101_state_message
    type: std::vector<std::string>
    restore_value: no
    # initial_value: '{"Init", "Waiting", "Recived Data", "Ready", "Error"}'
    initial_value: '{"Init", "Warte auf Daten", "Daten empfangen", "Ready", "Error"}'

## ------------------------------------------------------------------
## COMPONENT LOGGER
## https://esphome.io/components/logger.html
## ------------------------------------------------------------------
logger:
  id: appslogger
  level: ${log_level}
  baud_rate: ${log_baudrate}
  logs:
    sensor: ERROR
    text_sensor: ERROR
    light: ERROR
    component: ERROR
    mbus: ERROR
    wmbus: ERROR
    wMBus-lib: ERROR
    api: ERROR


## ------------------------------------------------------------------
## COMPONENT WIFI
## https://esphome.io/components/wifi.html
## ------------------------------------------------------------------
wifi:
  networks:
    # default wifi smarthome iot
    - ssid: !secret wifi_ssid
      password: !secret wifi_password
      priority: 100.00

    # fallback 1: wifi 2.4Ghz + 5GHz
    - ssid: !secret ssid2_name
      password: !secret ssid2_pswd
      priority: 50.0

    # fallback 2: wifi 2.4Ghz + 5GHz
    - ssid: !secret ssid3_name
      password: !secret ssid3_pswd
      priority: 30.0

    # fallback 3: wifi 2.4Ghz
    - ssid: !secret ssid4_name
      password: !secret ssid4_pswd
      priority: 10.0

  on_connect:
    - globals.set:
        id: wifi_connect
        value: !lambda "return id(wifi_connect)+=1;"
    - delay: 1s # Gives time for improv results to be transmitted
    # - ble.disable:  ??? how2do
    - logger.log:
        level: INFO
        tag: "WIFI-INFO"
        format: "Device has connected to wifi"

  on_disconnect:
    - logger.log:
        level: WARN
        tag: "WIFI-INFO"
        format: "Client disconnected from wifi, try recconect"

  domain: !secret domain
  reboot_timeout: 5min
  enable_on_boot: true
  power_save_mode: NONE

  # since we listed an SSID above, this AP mode will only enable if no WiFi connection could be made
  ap:
    ssid: ${hostname}_AP
    password: !secret hotspot_pswd

# ------------------------------------------------------------------
## COMPONENT Captive Portal
## ------------------------------------------------------------------
## The captive portal component in ESPHome is a fallback mechanism
## for when connecting to the configured WiFi fails.
## https://esphome.io/components/captive_portal.html
## ------------------------------------------------------------------
captive_portal:

# improv_serial:
# dashboard_import:
#   package_import_url: github://esphome/firmware/esp-web-tools/esp32s3.yaml@main

## ---------------------------------------------------
## mDNS Component
## https://esphome.io/components/mdns.html
## ---------------------------------------------------
mdns:
  # Both Home Assistant and the ESPHome dashboard use mDNS to identify the IP address
  # of all ESPHome nodes on the network. If mDNS is disabled, they will no longer
  # be able to automatically find your devices.
  disabled: false

## ------------------------------------------------------------------
## COMPONENT Over-the-Air Updates
## https://esphome.io/components/ota/#over-the-air-updates
## ------------------------------------------------------------------
ota:
  platform: esphome
  password: !secret ota_pswd
  on_begin:
    then:
      - logger.log:
          format: "OTA Start"
          tag: "OTA"
          level: WARN
  on_progress:
    then:
      - logger.log:
          level: WARN
          tag: "OTA"
          format: "OTA progress %0.1f%%"
          args: ["x"]
  on_end:
    then:
      - logger.log:
          format: "OTA End"
          tag: "OTA"
          level: WARN
  on_error:
    then:
      - logger.log:
          format: "OTA update error %d"
          tag: "OTA"
          level: ERROR
          args: ["x"]

## ------------------------------------------------------------------
## COMPONENT WEBSERVER
## The web_server component creates a simple web server on the node
## that can be accessed through any browser and a simple REST API.
## https://esphome.io/components/web_server.html
## ------------------------------------------------------------------
web_server:
  port: 80
  version: 3
  local: false
  js_url: !secret webserver3_jsurl

## ---------------------------------------------------
## COMPONENT Home Assistant API
## https://esphome.io/components/api.html
## Homeassistant service call (all values in liter):
## ---------------------------------------------------
## service: esphome.water_meter_esp_set_watermeter_esp_data
## data:
##   water_val_hour: 0.00
##   water_val_day: 167.00
##   water_val_yesterday: 240.35
##   water_val_week: 901.00
##   water_val_year: 33143.00
##   water_val_lastmonth: 7580.25
## ---------------------------------------------------
api:
  id: espapi_wmbus_esp32
  port: 6053
  reboot_timeout: 0s
  # https://esphome.io/components/api.html?highlight=api
  encryption:
    key: "inH49O9jBeK5yTGb1X2g4WV/1aS6YKUpu3Vu277fDgw="

  on_client_connected:
    - logger.log:
        format: "Client %s connected to API with IP %s, say hello"
        args: ["client_info.c_str()", "client_address.c_str()"]
  on_client_disconnected:
    - logger.log:
        format: "Client %s disconnected to API with IP %s, say goodbye"
        args: ["client_info.c_str()", "client_address.c_str()"]

  # service call from homeassistant to set the data
  services:
    - service: set_watermeter_esp_data
      variables:
        water_val_hour: float
        water_val_day: float
        water_val_yesterday: float
        water_val_week: float
        water_val_year: float
        water_val_lastmonth: float
      then:
        - logger.log:
            tag: "system"
            format: "Try to set new values: hour: %.3f, day: %.3f, yesterday: %.3f, week: %.3f, last month: %.3f, year: %.3f"
            level: INFO
            args:
              [
                "water_val_hour",
                "water_val_day",
                "water_val_yesterday",
                "id(week_value)",
                "id(lastmonth_value)",
                "id(year_value)",
              ]
        # new value for water hourly
        - globals.set:
            id: hour_value
            value: !lambda |-
              if((water_val_hour) and (water_val_hour)>0.001){
                ESP_LOGD("system", "Set hourly value to: %f", water_val_hour);
                return (water_val_hour);
              }else{
                ESP_LOGD("system", "Skip setting hourly value");
                return id(hour_value);
              };
              id(waterhour).publish_state(id(hour_value));
        - component.update: waterhour
        # new value for water daily
        - globals.set:
            id: daily_value
            value: !lambda |-
              if((water_val_day) and (water_val_day)>0.001){
                ESP_LOGD("system", "Set daily value to: %f", water_val_day);
                return (water_val_day);
              }else{
                ESP_LOGD("system", "Skip setting hourly value");
                return id(daily_value);
              };
              id(waterday).publish_state(id(daily_value));
        - component.update: waterday
        # new value for water yesterday
        - globals.set:
            id: yesterday_value
            value: !lambda |-
              if((water_val_yesterday) and (water_val_yesterday)>0.001){
                ESP_LOGD("system", "Set yesterday value to: %f", water_val_yesterday);
                return (water_val_yesterday);
              }else{
                ESP_LOGD("system", "Skip setting yesterday value");
                return id(yesterday_value);
              };
              id(wateryesterday).publish_state(id(yesterday_value));
        - component.update: wateryesterday
        # new value for water weekly
        - globals.set:
            id: week_value
            value: !lambda |-
              if((water_val_week) and (water_val_week)>0.001){
                ESP_LOGD("system", "Set weekly value to: %f", water_val_week);
                return (water_val_week);
              }else{
                ESP_LOGD("system", "Skip setting weekly value");
                return id(week_value);
              };
              id(waterweek).publish_state(id(week_value));
        - component.update: waterweek
        # new value for water lastmonth
        - globals.set:
            id: lastmonth_value
            value: !lambda |-
              if((water_val_lastmonth) and (water_val_lastmonth)>0.001){
                ESP_LOGD("system", "Set last month value to: %f", water_val_lastmonth);
                return (water_val_lastmonth);
              }else{
                ESP_LOGD("system", "Skip setting last month value");
                return id(lastmonth_value);
              };
              id(waterlastmonth).publish_state(id(lastmonth_value));
        - component.update: waterlastmonth
        # new value for water yearly
        - globals.set:
            id: year_value
            value: !lambda |-
              if((water_val_year) and (water_val_year)>0.001){
                ESP_LOGD("system", "Set last yearly value to: %f", water_val_year);
                return (water_val_year);
              }else{
                ESP_LOGD("system", "Skip setting last yearly value");
                return id(year_value);
              };
              id(wateryear).publish_state(id(year_value));
        - component.update: wateryear
        - logger.log:
            tag: "system"
            format: "All new Values set: hour: %.3f, day: %.3f, week: %.3f, last month: %.3f, year: %.3f"
            level: INFO
            args:
              [
                "id(hour_value)",
                "id(daily_value)",
                "id(week_value)",
                "id(lastmonth_value)",
                "id(year_value)",
              ]

## ---------------------------------------------------
## SNTP Time server
## https://esphome.io/components/time/sntp.html
## ---------------------------------------------------
time:
  - platform: sntp
    id: time_sntp
    timezone: Europe/Berlin
    servers:
      - !secret local_sntp
      - 0.at.pool.ntp.org
      - 0.pool.ntp.org
    on_time_sync:
      # Components should trigger on_time_sync when they update the system clock.
      then:
        - if:
            condition:
              lambda: 'return id(device_lastBoot_time).state == "";'
            then:
              - text_sensor.template.publish:
                  id: device_lastBoot_time
                  state: !lambda return id(time_sntp).now().strftime("%Y-%m-%dT%H:%M:%S %Z");
              - component.update: systime
              - component.update: watermeter_lastupdate

        - logger.log:
            level: WARN
            tag: "system"
            format: "Synchronized sntp clock"

        - script.execute: set_status_message

    on_time:
      # check cc1101 telegram state message every 30s
      - seconds: 30
        then:
          - script.execute: set_status_message

      # reset hourly value
      - seconds: 0
        minutes: 0
        then:
          - globals.set:
              id: hour_value
              value: "0.00"
          - lambda: id(waterhour).publish_state(id(hour_value));
          - logger.log:
              tag: "system"
              level: INFO
              format: "Reset value hour, starting next hour"

      # reset daily value and set yesterday value
      - seconds: 0
        minutes: 0
        hours: 0
        then:
          - lambda: |-
              id(yesterday_value)=id(daily_value);
              id(wateryesterday).publish_state(id(yesterday_value));
              id(daily_value)=0.00;
              id(waterday).publish_state(id(daily_value));
          - logger.log:
              tag: "system"
              level: INFO
              format: "Set yesterday value and reset value daily, starting new day"

      # reset weekly value, start new week
      - seconds: 0
        minutes: 0
        hours: 0
        days_of_week: MON
        then:
          - globals.set:
              id: week_value
              value: "0.00"
          - lambda: id(waterweek).publish_state(id(week_value));
          - logger.log:
              tag: "system"
              level: INFO
              format: "Reset value weekly, starting new week"

      # new year, reset yearly value
      - seconds: 0
        minutes: 0
        hours: 0
        days_of_month: 1
        months: JAN
        then:
          - globals.set:
              id: year_value
              value: "0.00"
          - lambda: id(wateryear).publish_state(id(year_value));
          - logger.log:
              tag: "system"
              level: INFO
              format: "Reset value yearly, starting new year"

## ---------------------------------------------------
## COMPONENT SCRIPTS
## ---------------------------------------------------
script:
  - id: set_status_message
    then:
      - lambda: |-
          int msgcode = int(id(cc1101_state));
          std::string message = id(cc1101_state_message)[msgcode];
          ESP_LOGD("wmbus", "cc1101 state message: %s, error code: %d", message.c_str(), msgcode);
          id(watermeter_status_message).publish_state(message);

## ---------------------------------------------------------------------------------
##                       ATOM LITE  S3 +  WMBUS EBYTE TI CC1101
## ---------------------------------------------------------------------------------
##
##
##                           ╭―――――――――――――――――――――――――――――――――╮
##                           │         ╭―――――――――――――――╮       │
##                           │         │ ATOM LITE  S3 │       │
##                           │         │   ESP32S3FN8  │       │
##                           │         ╰―――――――――――――――╯       │
##   rot     1 ■ <---  3.3V  │ [■]                             │
##   violet  4 ■ <--- GPIO22 │ [■] CSN                 SCL [ ] │ GIPO21
##   orange  3 ■ <--- GPIO19 │ [■] MOSI                SDA [ ] │ GIPO25
##   braun   8 ■ <--- GPIO23 │ [■] CLK ╭―――――――――――――――╮   [ ] │ 5V
##   grün    5 ■ <--- GPIO33 │ [■] MISO│               │   [■] │ GND  ---> ■ 2 GND schwarz
##                           │         │     USB       │       │
##                           ╰―――――――――――――――――――――――――――――――――╯
##                                     │               │
##                                     │    PORT.A     │
##                                     ╰―――――――――――――――╯
##                                       [■] GND BLACK   --------------> ■
##                                         [■] 5V RED    --------------> ■
##                                            [■] GIPO26  Yellow ------> ■ 7: gelb RX Clock output
##                                              [■] GIPO32 WHITE ------> ■ 6: blau TX FIFO status signals
##
##                                 ^
##                                 │      EBYTE TI CC1101
##                                 │     ╭―――――――――――――――╮
##                                 │   ■ │ GND        GND│
##                                 +---■ │ ANT        GND│ ■ black --> ■ 2 GND
##                                     ■ │ GND        GND│
##                                       │               │
##                                       │               │
##             GIPO22 4 <---  ■ violet ■ │ CSN        GND│
##             GIPO23 8 <---  ■ braun  ■ │ SDK        GND│
##             GIPO19 3 <---  ■ orange ■ │ MOSI        NC│
##             GIPO33 5 <---  ■ grün   ■ │ MISO        NC│
##             GIPO26 7 <---  ■ gelb   ■ │ GDO00       NC│
##             GIPO32 6 <---  ■ blau   ■ │ GDO02      VCC│ ■ red   --> ■ 1 3.3V
##                                       │ NC          NC│
##                                       │ GND        GND│
##                                       ╰―――――――――――――――╯
##
##       INTERNAL PINS   ■ BIG BUTTON: GIPO36   ■ LED-NEO: GIPO27  ■ IR : GIPO12
##
## ---------------------------------------------------------------------------------
wmbus:
  cs_pin: 22 ## CSN:  violett  8: CSN  Attached to Hardware SPI controller
  clk_pin: 23 ## SCLK: braun    4: SCK  Attached to Hardware SPI controller CLK
  mosi_pin: 19 ## MOSI: orange   3: MOSI Attached to Hardware SPI controller MOSI SPI Interface
  miso_pin: 33 ## MISO: grün     5: MISO Attached to Hardware SPI controller MISO SPI Interface
  gdo0_pin: 26 ## GD00: gelb     7: RX Clock output. High Impedance !
  gdo2_pin: 32 ## GD02: weiss    6: TX FIFO status signals. High Impedance !

  log_unknown: False

## ---------------------------------------------------
## SWITCHES
## ---------------------------------------------------
button:
  # reset boot counter value
  - platform: template
    name: "${friendly_name} Boot Counter Reset"
    id: btn_bc
    icon: mdi:counter
    disabled_by_default: false
    entity_category: config
    web_server_sorting_weight: 12
    on_press:
      then:
        - lambda: id(boot_counter) = 0; id(bootcounter).publish_state(id(boot_counter));
        - logger.log:
            level: WARN
            tag: "system"
            format: "${hostname} reset boot counter o.k!"
        - component.update: bootcounter

  # reset all global vars
  - platform: template
    name: "${friendly_name} Reset values"
    icon: mdi:lock-reset
    entity_category: config
    web_server_sorting_weight: 13
    on_press:
      then:
        - lambda: |-
            id(last_value) = 0.00;
            id(boot_counter) = 0;
            id(bootcounter).publish_state(id(boot_counter));
            id(current_value) = 0.00;
            id(watercurrent).publish_state(id(current_value));
            id(hour_value) = 0.00;
            id(waterhour).publish_state(id(hour_value));
            id(daily_value) = 0.00;
            id(waterday).publish_state(id(daily_value));
            id(yesterday_value) = 0.00;
            id(wateryesterday).publish_state(id(yesterday_value));
            id(week_value) = 0.00;
            id(waterweek).publish_state(id(week_value));
            id(lastmonth_value) = 0.00;
            id(waterlastmonth).publish_state(id(lastmonth_value));
            id(year_value) = 0.00;
            id(wateryear).publish_state(id(year_value));
        - logger.log:
            level: INFO
            tag: "system"
            format: "all values reset!"

  # simple button for restart
  - platform: restart
    name: ${friendly_name} Restart
    id: restart_device
    disabled_by_default: false
    entity_category: config
    icon: mdi:restart
    web_server_sorting_weight: 14

  # internal led on / off
  - platform: template
    name: "${friendly_name} Geräte Led"
    id: btn_led
    icon: mdi:toggle-switch-off
    disabled_by_default: false
    entity_category: config
    on_press:
      then:
        - light.toggle: internal_led

## ---------------------------------------------------
## Configuration of M5 Atom Lite onboard RGB LED
## only used internal
## https://esphome.io/components/light/index.html
## https://esphome.io/components/light/fastled.html
## ---------------------------------------------------
light:
  - platform: fastled_clockless
    chipset: WS2812
    pin: 27
    num_leds: 1
    rgb_order: grb
    id: internal_led
    icon: mdi:led-outline
    restore_mode: ALWAYS_ON
    web_server_sorting_weight: 8
    entity_category: config

# ----------------------------------------------------------------
# BINARY SENSOR
# https://esphome.io/components/binary_sensor/
# ----------------------------------------------------------------
binary_sensor:
  # simulate led state (updated by id: "waterdisplay")
  - platform: template
    name: "${friendly_name} Status Led"
    id: statusled
    icon: mdi:led-outline
    entity_category: "diagnostic"
    lambda: "return id(current_value) > 0;"
    web_server_sorting_weight: 19

  # ATOM Lite Big Button
  - platform: gpio
    name: "${friendly_name} Schalter"
    icon: mdi:toggle-switch-off
    id: btn_bigbutton
    pin:
      number: GPIO39
      inverted: true
    internal: false

  # The Status Binary Sensor exposes the node state
  # (if it’s connected to via MQTT/native API) for Home Assistant.
  # https://esphome.io/components/binary_sensor/status.html
  - platform: status
    name: ${friendly_name} API Status
    id: device_api_status
    disabled_by_default: true
    icon: mdi:state-machine
    entity_category: diagnostic
    web_server_sorting_weight: 23

## ---------------------------------------------------
## SENSOREN
## https://esphome.io/components/sensor/
## ---------------------------------------------------
sensor:
  - platform: wmbus

    # Meter ID (usually from sticker). Can be specified as decimal or hex.
    # --------------------------------------------------------------------
    # Meter ID only HEX is working for my watermeter !
    # 1. find the Meter ID with meter_id: "0"
    # 2. log shows the Meter ID [14:08:40][I][wmbus:060]: Using driver 'izar' for ID [0x43430778] RSSI: -63 dBm T: 1944A5117...
    # 3. change meter_id: 0x43430778
    # 4. edit watermeterid in the secrets file
    # --------------------------------------------------------------------
    # see: https://github.com/SzczepanLeon/esphome-components/issues/6
    meter_id: !secret watermeterId
    type: izar
    # add_prefix: enable/disable add watermeterid to lqi, rssi, total_water_m3
    add_prefix: false

    # The LQI value reported by the CC1101 is a 7 bit unsigned number with a range from 0 to 127.
    # Note that a lower value indicates a better link.
    # The LQI of a received packet will be bad (higher number) when there is lot of interference.
    lqi:
      id: wmbus_cc1101_lqi
      name: "${friendly_name} LQI"
      entity_category: "diagnostic"
      unit_of_measurement: dBm
      device_class: signal_strength
      state_class: "measurement"
      icon: mdi:rss
      web_server_sorting_weight: 22

    # The RSSI value reported by the CC1101 is a 8 bit signed number with an effective
    # range from -138 dBm to -10.5 dBm when the CC1101 is operating around 868 MHz.
    # RSSI stands for received signal strength (power) indication (in dBm).
    # A higher value indicates higher power. (internal only) see id: cc1101_rssi
    rssi:
      id: wmbus_cc1101_rssi
      name: "${friendly_name} RSSI"
      icon: mdi:rss
      unit_of_measurement: "Signal %"
      entity_category: "diagnostic"
      state_class: "measurement"
      device_class: ""
      web_server_sorting_weight: 23
      filters:
        - filter_out: nan
        - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);

    # get the total watermter m3 from the wmbus telegram, log the timestamp
    # for the last reading  and calculates the statitics value
    # and update all sensors: last_value, watercurrent, hour_value, daily_value
    # week_value, month_value, year_value and watermeter_lastupdate
    total_water_m3:
      id: "waterdisplay"
      name: "${friendly_name} Anzeige"
      unit_of_measurement: "m³"
      state_class: total_increasing
      device_class: "water"
      accuracy_decimals: 3
      icon: mdi:counter
      web_server_sorting_weight: 1
      # Send the value periodically with the specified time interval.
      # If the sensor value changes during the interval the interval will not reset.
      # The last value of the sensor will be sent. 60s means, that every minute the
      # last state will be published.
      # The IZAR Watermeter will publish data all 8s (see transmit_period_s),
      # but we need this only evers minute.
      # filters:
      #   - heartbeat: 60s
      # update and calculate all watermeter sensor data values
      on_value:
        then:
          - lambda: |-
              if ((id(last_value) > 0.00) and (id(waterdisplay).state)>(id(last_value)) ) {
                id(cc1101_state) = 2;
                ESP_LOGD("wmbus", "Water Display value: %.3f, last value: %.3f", id(waterdisplay).state, id(last_value));
                id(current_value) = float(id(waterdisplay).state-id(last_value)) * 1000.00;
                id(watercurrent).publish_state(id(current_value));
                id(hour_value)+=id(current_value);
                id(waterhour).publish_state(id(hour_value));
                id(daily_value)+=id(current_value);
                id(waterday).publish_state(id(daily_value));
                id(week_value)+=id(current_value);
                id(waterweek).publish_state(id(week_value));
                id(year_value)+=id(current_value);
                id(wateryear).publish_state(id(year_value));
                ESP_LOGD("wmbus", "Set current value to %.3f litre and publish the data", id(current_value));
              }else{
                id(current_value) = 0.00;
                id(cc1101_state) = 1;
                id(watercurrent).publish_state(id(current_value));
                ESP_LOGD("wmbus", "Reset current value to: %.3f, Waterdisplay value: %.3f, last value: %.3f", id(current_value), id(waterdisplay).state, id(last_value));
              }
              id(last_value)=id(waterdisplay).state;

          # calculate the water usage in percent
          - component.update: watercurrent
          - component.update: waterhour
          - component.update: waterday
          - component.update: waterweek
          - component.update: wateryear
          - component.update: water_consumption

          # update the watermeter_lastupdate timestamp for the last waterdisplay state
          - text_sensor.template.publish:
              id: watermeter_lastupdate
              state: !lambda return id(time_sntp).now().strftime("%Y-%m-%dT%H:%M:%S %Z");
          - component.update: watermeter_lastupdate

          # update watermeter_read_timeout the reading timeout for the watermeter display
          - sensor.template.publish:
              id: watermeter_read_timeout
              state: !lambda |-
                int time_used = ( millis() - id(send_millisecond) );
                ESP_LOGD("wmbus", "Diff millisecond is: %d", time_used);
                id(send_millisecond) = millis();
                return float(time_used)/1000;
          - component.update: watermeter_read_timeout
          # update the watermeter status
          - script.execute: set_status_message

          # update the status led (statusled)
          - binary_sensor.template.publish:
              id: statusled
              state: !lambda "return id(current_value) > 0;"

          # toggle internal led on value
          - light.turn_on: internal_led
          - delay: 200ms
          - light.turn_off: internal_led

    # water current month (wM-Bus)
    current_month_total_water_l:
      name: Wasser Monat
      id: "watermonth"
      accuracy_decimals: 2
      unit_of_measurement: "L"
      icon: mdi:water-outline
      state_class: total_increasing
      device_class: "water"
      web_server_sorting_weight: 7

    # get the last month total watermter m3 from the wmbus telegram  (wM-Bus)
    last_month_total_water_m3:
      name: "${friendly_name} Anzeige letzter Monat"
      id: "waterdisplay_lastmonth"
      unit_of_measurement: "m³"
      state_class: total_increasing
      device_class: "water"
      accuracy_decimals: 3
      icon: mdi:counter
      web_server_sorting_weight: 11

    # get the battery life time (wM-Bus)
    remaining_battery_life_y:
      name: "${friendly_name} Batterielebensdauer"
      id: "watermeter_batterie"
      accuracy_decimals: 2
      unit_of_measurement: "Jahre"
      state_class: "measurement"
      entity_category: "diagnostic"
      icon: mdi:battery
      web_server_sorting_weight: 21

    # get the last transmit periode (wM-Bus)
    transmit_period_s:
      name: "${friendly_name} Update Intervall"
      id: "watermeter_transmit_periode"
      unit_of_measurement: "sec"
      state_class: "measurement"
      accuracy_decimals: 2
      entity_category: "diagnostic"
      icon: mdi:timelapse
      web_server_sorting_weight: 18

    ## get the current watermeter alarms and publish the text message (wM-Bus)
    ## see: id: watermeter_alarm_message
    current_alarms:
      id: "watermeter_current_alarms"
      name: "${friendly_name} Alarm Code"
      entity_category: "diagnostic"
      icon: mdi:message-alert-outline
      web_server_sorting_weight: 25
      on_value:
        then:
          - lambda: |-
              int error_code = int(x);
              std::string message = "";
              if(error_code==0){
                  message = id(alarm_error_text)[error_code];
                  id(watermeter_alarm_message).publish_state(message);
                  ESP_LOGD("wmbus", "Alarm message: %s, error code: %d", message, error_code);
              }else{
                for (int i = 1; i < 10; ++i) {
                  if (error_code & (1 << i)) {
                    if (!message.empty()) {
                      message += ", ";
                    }
                    message += id(alarm_error_text)[i];
                  }
                }
                id(watermeter_alarm_message).publish_state(message);
                ESP_LOGW("wmbus", "WARNING Alarm message: %s, error code: %d", message.c_str(), error_code);
                id(watermeter_alarm_timestamp).publish_state(id(time_sntp).now().strftime("%Y-%m-%dT%H:%M:%S %Z").c_str());
              }
          - component.update: watermeter_alarm_message

    ## get the prevois watermeter alarms and publish the text message (wM-Bus)
    ## see: id: watermeter_alarm_perv_message
    previous_alarms:
      id: "watermeter_previous_alarms"
      name: "${friendly_name} Alarm Code voriger"
      icon: mdi:message-alert
      entity_category: "diagnostic"
      web_server_sorting_weight: 27
      on_value:
        then:
          - lambda: |-
              int error_code = int(x);
              std::string message = "";
              if(error_code==0){
                  message = id(alarm_error_text)[error_code];
                  id(watermeter_alarm_message).publish_state(message);
                  ESP_LOGD("wmbus", "Alarm message: %s, error code: %d", message, error_code);
              }else{
                for (int i = 1; i < 10; ++i) {
                  if (error_code & (1 << i)) {
                    if (!message.empty()) {
                      message += ", ";
                    }
                    message += id(alarm_error_text)[i];
                  }
                }
                ESP_LOGW("wmbus", "WARNING Alarm message: %s, error code: %d", message.c_str(), error_code);
                id(watermeter_alarm_timestamp).publish_state(id(time_sntp).now().strftime("%Y-%m-%dT%H:%M:%S %Z").c_str());
              }
              id(watermeter_alarm_perv_message).publish_state(message);
              if(id(watermeter_alarm_timestamp).has_state() == false) {
                id(watermeter_alarm_timestamp).publish_state("--");
              }
          - component.update: watermeter_alarm_message
          - component.update: watermeter_alarm_perv_message

  # water current (updated by id: "waterdisplay")
  - platform: template
    name: Wasser Aktuell
    id: "watercurrent"
    accuracy_decimals: 2
    unit_of_measurement: "L"
    icon: mdi:water-circle
    device_class: "water"
    state_class: total_increasing
    lambda: return (id(current_value));
    web_server_sorting_weight: 2

  # water current hour (updated by id: "waterdisplay")
  - platform: template
    name: Wasser Stunde
    id: "waterhour"
    accuracy_decimals: 2
    unit_of_measurement: "L"
    icon: mdi:water-circle
    state_class: total_increasing
    device_class: "water"
    lambda: return (id(hour_value));
    web_server_sorting_weight: 3

  # water today (updated by id: "waterdisplay")
  - platform: template
    name: Wasser Tag
    id: "waterday"
    accuracy_decimals: 2
    unit_of_measurement: "L"
    icon: mdi:water-circle
    device_class: "water"
    state_class: total_increasing
    lambda: return (id(daily_value));
    web_server_sorting_weight: 4

  # water yesterday (updated by id: "waterdisplay")
  - platform: template
    name: Wasser Gestern
    id: "wateryesterday"
    accuracy_decimals: 2
    unit_of_measurement: "L"
    icon: mdi:water-circle
    device_class: "water"
    state_class: total_increasing
    lambda: return (id(yesterday_value));
    web_server_sorting_weight: 5

  # water current week (updated by id: "waterdisplay")
  - platform: template
    name: Wasser Woche
    id: "waterweek"
    accuracy_decimals: 2
    unit_of_measurement: "L"
    icon: mdi:water-circle
    device_class: "water"
    state_class: total_increasing
    lambda: return (id(week_value));
    web_server_sorting_weight: 6

  # water last month (updated by id: "waterdisplay")
  - platform: template
    name: Wasser letzer Monat
    id: "waterlastmonth"
    icon: mdi:water-outline
    accuracy_decimals: 2
    unit_of_measurement: "L"
    state_class: total_increasing
    device_class: "water"
    lambda: return (id(lastmonth_value));
    web_server_sorting_weight: 9

  # water current year (updated by id: "waterdisplay")
  - platform: template
    name: Wasser Jahr
    id: "wateryear"
    icon: mdi:water-outline
    accuracy_decimals: 2
    unit_of_measurement: "L"
    state_class: total_increasing
    device_class: "water"
    lambda: return (id(year_value));
    web_server_sorting_weight: 10

  # ratio lastmonth to current month (updated by id: "waterdisplay")
  - platform: template
    name: Wasser Verbrauch
    id: water_consumption
    web_server_sorting_weight: 11
    unit_of_measurement: "%"
    state_class: measurement
    icon: "mdi:percent"
    accuracy_decimals: 2
    filters:
      - filter_out: nan
    lambda: |-
      if(id(waterlastmonth).state > 0.00){
       return ( id(watermonth).state / id(waterlastmonth).state * 100.00 );
      }else{
       return 0.00;
      }

  # service call delay (updated by id: "waterdisplay")
  - platform: template
    name: ${friendly_name} Daten Intervall
    id: watermeter_read_timeout
    icon: mdi:clock-start
    accuracy_decimals: 2
    unit_of_measurement: "sec"
    state_class: "measurement"
    entity_category: "diagnostic"
    web_server_sorting_weight: 17

  # get the wifi signal from the esp device
  - platform: wifi_signal
    id: wifisignal
    name: ${friendly_name} WiFi Signal
    icon: mdi:wifi-strength-1
    update_interval: 60s
    entity_category: diagnostic
    disabled_by_default: true
    unit_of_measurement: dBm
    accuracy_decimals: 0
    device_class: signal_strength
    state_class: measurement
    web_server_sorting_weight: 29

  # calulcate the wifi signal quality
  - platform: copy # wifi signal in %
    source_id: wifisignal
    id: sensor_wifi_signal_percentage
    name: ${friendly_name} WiFi Qualität
    icon: mdi:wifi-strength-1
    unit_of_measurement: "%"
    state_class: "measurement"
    device_class: ""
    entity_category: diagnostic
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    accuracy_decimals: 2
    web_server_sorting_weight: 35

  # device internal temperature (only webserver)
  - platform: internal_temperature
    name: ${friendly_name} Gerätetemperatur
    id: device_internal_temperature
    icon: mdi:thermometer-lines
    unit_of_measurement: "°C"
    accuracy_decimals: 2
    device_class: temperature
    state_class: measurement
    update_interval: 60s
    entity_category: "diagnostic"
    disabled_by_default: true

  # Uptime device in hours
  - platform: uptime
    name: "${friendly_name} Online seit"
    id: uptime_human
    icon: mdi:clock-start
    filters:
      - filter_out: nan
      - lambda: return x / 3600;
    unit_of_measurement: "h"
    entity_category: "diagnostic"
    state_class: "measurement"
    accuracy_decimals: 2
    web_server_sorting_weight: 16

  # device boot counter by device boot
  - platform: template
    name: ${friendly_name} Anzahl Neustarts
    id: bootcounter
    icon: mdi:counter
    accuracy_decimals: 0
    state_class: "measurement"
    entity_category: "diagnostic"
    lambda: return (id(boot_counter));
    web_server_sorting_weight: 15

  # wifi connect counter
  - platform: template
    name: ${friendly_name} Wifi Zähler
    id: wificounter
    icon: mdi:counter
    accuracy_decimals: 0
    state_class: "measurement"
    entity_category: "diagnostic"
    lambda: return (id(wifi_connect));
    web_server_sorting_weight: 15

  - platform: template
    name: CC1101 I2C
    device_class: connectivity
    entity_category: diagnostic
    lambda: "return !id(wmbus_component).is_failed();"   

## ---------------------------------------------------------
## Template Datetime
## https://esphome.io/components/datetime/template.html
## ---------------------------------------------------------
datetime:
  - platform: template
    id: wm_installed
    name: "${friendly_name} installiert"
    type: datetime
    optimistic: yes
    initial_value: ${watermeter_installed}
    restore_value: true
    disabled_by_default: true
    entity_category: "diagnostic"
    icon: mdi:clock-start
    web_server_sorting_weight: 36

## ---------------------------------------------------------
## Debug Component
## https://esphome.io/components/debug.html
## ---------------------------------------------------------
debug:
  update_interval: 5s

## ---------------------------------------------------
## TEXT SENSOR
## ---------------------------------------------------
text_sensor:

  - platform: debug
    # Reports the last reboot reason in a human-readable form.
    reset_reason:
      name: "${friendly_name} Reset Reason"
      id: reboot_reason
      icon: mdi:message-alert-outline
      web_server_sorting_weight: 15

  # watermeter status message (updated by script: set_status_message)
  - platform: template
    name: "${friendly_name} Status Info"
    id: watermeter_status_message
    icon: mdi:bell
    entity_category: "diagnostic"
    web_server_sorting_weight: 20

  # watermeter alarm message (updated by id: current_alarms)
  - platform: template
    name: "${friendly_name} Alarm"
    id: watermeter_alarm_message
    icon: mdi:alarm-light
    entity_category: "diagnostic"
    web_server_sorting_weight: 26

  # watermeter previous alarm message (updated by id: current_prev_alarms)
  - platform: template
    name: "${friendly_name} Alarm voriger"
    id: watermeter_alarm_perv_message
    icon: mdi:alarm-light
    entity_category: "diagnostic"
    web_server_sorting_weight: 28

  # watermeter alarm timestamp (updated by id: current_alarms)
  - platform: template
    name: "${friendly_name} Alarm Zeit"
    id: watermeter_alarm_timestamp
    icon: mdi:alarm-light
    entity_category: "diagnostic"
    web_server_sorting_weight: 24

  # optional device version
  - platform: version
    name: "${friendly_name} ESPHome Version"
    icon: mdi:information-box-outline
    id: appver
    entity_category: "diagnostic"
    hide_timestamp: true
    disabled_by_default: true
    web_server_sorting_weight: 39

  # Last boot timestamp (updated by device boot)
  - platform: template
    name: "${friendly_name} Last Boot"
    disabled_by_default: true
    id: device_lastBoot_time
    icon: mdi:clock-start
    entity_category: "diagnostic"
    web_server_sorting_weight: 37

  # waterdisplay timestamp last update (updated by id: "waterdisplay")
  - platform: template
    name: "${friendly_name} Daten vom"
    id: watermeter_lastupdate
    icon: mdi:clock-start
    web_server_sorting_weight: 11

  # optional device timestamp
  - platform: template
    id: systime
    name: "${friendly_name} Uhrzeit"
    disabled_by_default: true
    entity_category: "diagnostic"
    icon: mdi:clock-start
    lambda: return id(time_sntp).now().strftime("%Y-%m-%dT%H:%M:%S %Z");
    web_server_sorting_weight: 36

  # Wifi Info (parts only on webserver)
  # https://esphome.io/components/text_sensor/wifi_info.html
  - platform: wifi_info

    # get the current ssid from the wifi card
    ssid:
      name: ${friendly_name} WIFI SSID
      id: wlan_ssid
      icon: mdi:wifi-settings
      entity_category: "diagnostic"
      web_server_sorting_weight: 30

    # get the current bssid from the wifi card
    bssid:
      name: ${friendly_name} WIFI BSSID
      icon: mdi:wifi-star
      disabled_by_default: true
      entity_category: "diagnostic"
      web_server_sorting_weight: 31

    # get the current used ip address from the wifi card
    ip_address:
      name: ${friendly_name} WIFI IP Address
      icon: mdi:ip
      disabled_by_default: true
      entity_category: "diagnostic"
      web_server_sorting_weight: 34

    # get the current mac address from the wifi card
    mac_address:
      name: ${friendly_name} WIFI MAC-Addresse
      icon: mdi:fingerprint
      entity_category: "diagnostic"
      disabled_by_default: true
      web_server_sorting_weight: 34

    # get the used dns server from the wifi card
    dns_address:
      name: ${friendly_name} WIFI DNS Address
      icon: mdi:dns
      disabled_by_default: true
      entity_category: "diagnostic"
      web_server_sorting_weight: 32

  # simple rest get message for all watermeter data
  # (disable this if you do not need rest service)
  # you can get the sensor data with:
  #   curl -i http://atom-watermeter.local/text_sensor/watermeterdata
  - platform: template
    id: watermeterdata
    internal: true
    disabled_by_default: true
    lambda: |-
      char buf[128];
      sprintf(buf, "%.3f│%.3f│%.3f│%.3f│%.3f│%.3f│%.3f│%.3f│%.3f│%s",
             id(waterdisplay).state,
             id(current_value),
             id(hour_value),
             id(daily_value),
             id(yesterday_value),
             id(week_value),
             id(watermonth).state,
             id(lastmonth_value),
             id(year_value),
             id(systime).state.c_str()
             );
      std::string s = buf;
      return s;

# e.o.f configuration esp32
